#lang rhombus/static

export:
  index_of
  index_where
  splitf_at
  subtract
  intersect

fun index_of(lst :: List, v) :: maybe(Int):
  for any (e: lst, i: 0..):
    keep_when: e == v
    i

module test:
  check: index_of([#'a, #'b, #'c], #'a) ~is 0
  check: index_of([#'a, #'b, #'c], #'b) ~is 1
  check: index_of([#'a, #'b, #'c], #'c) ~is 2
  check: index_of([#'a, #'b, #'c], #'d) ~is #false

fun index_where(lst :: List, pred) :: maybe(Int):
  for any (e: lst, i: 0..):
    keep_when: pred(e)
    i

module test:
  fun is_even(i :: Int) :: Boolean: (i mod 2) == 0
  fun is_odd(i :: Int) :: Boolean: (i mod 2) == 1
  check: index_where([1, 2, 3, 4], is_even) ~is 1
  check: index_where([1, 21, 3, 4], is_even) ~is 3

fun splitf_at(lst :: List, pred) :: values(List, List):
  let i: index_where(lst, fun (e): !pred(e))
  cond
  | !i: values(lst, [])
  | ~else:
      values(lst.sublist(0, i), lst.sublist(i, lst.length()))

module test:
  check: splitf_at([2, 4, 5, 8], is_even) ~is values([2, 4], [5, 8])
  check: splitf_at([2, 4, 5, 8], is_odd) ~is values([], [2, 4, 5, 8])
  check: splitf_at([2, 4, 6, 8], is_even) ~is values([2, 4, 6, 8], [])
  check: splitf_at([2, 4, 6, 8], is_odd) ~is values([], [2, 4, 6, 8])

fun subtract(as :: List, bs :: List) :: List:
  for List (a: as):
    keep_when: !bs.has_element(a)
    a

module test:
  check: subtract([1, 2, 3, 2, 4, 5, 2], [1, 2]) ~is [3, 4, 5]
  check: subtract([1, 2, 3, 2, 4, 5, 2], [3, 4, 5]) ~is [1, 2, 2, 2]

fun intersect(as :: List, bs :: List) :: List:
  for List (a: as):
    keep_when: bs.has_element(a)
    a

module test:
  check: intersect([1, 2, 3, 2, 4, 5, 2], [1, 2]) ~is [1, 2, 2, 2]
  check: intersect([1, 2, 3, 2, 4, 5, 2], [3, 4, 5]) ~is [3, 4, 5]

